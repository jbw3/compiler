fun noArgs() i32
{
    42
}

fun oneArg(x i32) i32
{
    x + 2
}

fun integerLiterals(x i32) i32
{
    0b101 + x + 0o370 + x + 123 + x + 0x_a5_7F93
}

fun twoArgs(arg1 i32, arg2 i32) i32
{
    arg1 - arg2
}

fun opOrder1(a i32, b i32, c i32, d i32) i32
{
    a + b * c - d
}

fun opOrder2(a i32, b i32, c i32, d i32) i32
{
    a + b * c - d / a + b % 42
}

fun opOrder3(a i32, b i32, c i32, d i32) bool
{
    a == b + c * d
}

fun opOrder4(a i32, b i32, c i32, d i32, e i32, f i32) i32
{
    a | b ^ c & d << e >> f >>> a
}

fun opOrder5(a i32, b i32, c i32, d i32) i32
{
    ( -(a + b) + opOrder6(a, b, c, d) ) * d
}

fun opOrder6(a i32, b i32, c i32, d i32) i32
{
    (a | b) ^ (c & d)
}

fun negatives(a i32, b i32, c i32) i32
{
    -a - -b * -oneArg(2 + -c)
}

fun not(a i32, b i32) i32
{
    !a & !b | !noArgs()
}

fun equal(a i32, b i32) bool
{
    a == b
}

fun notEqual(a i32, b i32) bool
{
    a != b
}

fun lessThan(a i32, b i32) bool
{
    a < b
}

fun lessThanOrEqual(a i32, b i32) bool
{
    a <= b
}

fun greaterThan(a i32, b i32) bool
{
    a > b
}

fun greaterThanOrEqual(a i32, b i32) bool
{
    a >= b
}

fun logicalAnd2(x i32, y i32, z i32) bool
{
    x != 0 && y < z + 5
}

fun logicalAnd3(x i32, y i32, z i32) bool
{
    x == 0 && y == 1 && z == 2
}

fun logicalOr2(x i32, y i32, z i32) bool
{
    z == 0 || x + y / z < 100
}

fun logicalOr3(x i32, y i32, z i32) bool
{
    x == 0 || y == 1 || z == 2
}

fun assignOps(a i8, b i16, c i32)
{
    c += a;
    c -= a + b;
    c *= a;
    c /= a + b;
    c %= a;
    c <<= a + b;
    c >>= a;
    c >>>= b;
    c &= a + b;
    c ^= a;
    c |= a + b;
}

fun nestedCall(x i32, y i32, z i32) i32
{
    twoArgs(0, x) + twoArgs(y + 42, z - 57)
}

fun call_function_defined_later(a bool, b bool) bool
{
    types_bool(a, b)
}

fun types_unit(number i64)
{
}

fun types_unit2()
{
    types_unit(123)
}

fun types_bool(a bool, b bool) bool
{
    a | b
}

fun types_i8(n1 i8, n2 i8) i8
{
    n1 + n2
}

fun types_i16(n1 i16, n2 i16) i16
{
    n1 - n2
}

fun types_i32(n1 i32, n2 i32) i32
{
    n1 * n2
}

fun types_i64(n1 i64, n2 i64) i64
{
    n1 / n2
}

fun types_isize(n1 isize, n2 isize) isize
{
    n1 % n2
}

fun types_u8(n1 u8, n2 u8) u8
{
    n1 % n2
}

fun types_u16(n1 u16, n2 u16) u16
{
    n1 / n2
}

fun types_u32(n1 u32, n2 u32) u32
{
    n1 * n2
}

fun types_u64(n1 u64, n2 u64) u64
{
    n1 - n2
}

fun types_usize(n1 usize, n2 usize) usize
{
    n1 + n2
}

fun types_str()
{
    var s1 str = ""; # empty string
    var s2 str = "Is this a test?"; # simple chars
    var s3 str = "\t\r\n\\\"\'"; # escape sequences
    var s4 str = "café"; # unicode
    var s5 str = "\x4a\x42\x57"; # byte escape sequences
    var s6 str = "\u{a}\u{30}\u{3c0}\u{20BF}\u{1F600}"; # unicode escape sequences

    # these should point to the same constant
    var dup1 str = "abc";
    var dup2 str = "abc";
}

fun str_member1() usize
{
    var s str = "abc";
    var size usize = s.Size;
    size
}

fun str_member2(x i32) usize
{
    if x == 0
    {
        "abc"
    }
    else
    {
        "café"
    }.Size
}

fun types_add_literal(num i8) i8
{
    # make sure we can add a constant literal to a number with a small size
    num + 1
}

fun sign_extend_bin_op(a i8, b i16, c i64, d i32) i64
{
    a * b / c % d
}

fun sign_extend_ret(param i32) i64
{
    param + 5
}

fun sign_extend_call(param i8) i64
{
    sign_extend_ret(param)
}

fun basicBranch(x i32, y i32, z i32) i32
{
    if x + 1 == y / 2
    {
        z * 10
    }
    else
    {
        -z
    }
}

fun signExtendBranch(b bool, x i16, y i16) i64
{
    if b
    {
        types_i16(x, y)
    }
    else
    {
        types_i32(x, y)
    }
}

fun nestedBranches(x i32, y i32, z i32) i32
{
    if x == 0
    {
        y + z
    }
    else
    {
        if x == 1
        {
            y - z
        }
        else
        {
            y * z
        }
    }
}

fun elseIfBranches(x i32, y i32, z i32) i32
{
    if x == 0
    {
        y + z
    }
    elif x == 1
    {
        y - z
    }
    elif x == 2
    {
        y * z
    }
    else
    {
        42
    }
}

fun noElseBranches(x i32, y i32) i32
{
    var z i32 = 0;
    if x == 0
    {
        z = x + y;
    }

    if y < -5
    {
        z *= 2;
    }
    elif y > 5
    {
        z /= 2;
    }

    z
}

fun elseIfBranchesNesting(x i32, y i32, z i32) i32
{
    if x == 0
    {
        y + z
    }
    elif x == 1
    {
        y - z
    }
    elif x == 2
    {
        y * z
    }
    elif x == 3
    {
        if z == 0
        {
            0
        }
        else
        {
            y / z
        }
    }
    else
    {
        if z == 0
        {
            0
        }
        else
        {
            y % z
        }
    }
}

fun branchInExpression(x i32, y i32, z i32) i32
{
    if x == 0
    {
        y
    }
    else
    {
        z
    } + 58
}

fun branchWithLogicalOperators(x i32, y i32, z i32) i32
{
    if x == 0 && y == 1 || z == 1
    {
        100
    }
    else
    {
        200
    }
}

fun assign(a i32, b i32, c i32) i32
{
    a = b * c;
    b = a + 3 * b + c;
    c = c + 42;
    c
}

fun assignWithBranch(a i32, b i32, c i64) i64
{
    c =
        if b <= 0
        {
            a * b + c
        }
        else
        {
            a / b - c
        };
    c = c * 2;
    c
}

fun assignInBranch(a i32, b i32, c i32) i32
{
    c =
        if a <= 0
        {
            b = 0xA;
            c + 1
        }
        else
        {
            b = 10_000;
            c + 2
        };
    c = b * c;
    c
}

fun createVars(num i32) i64
{
    var rv i64 =
        if num < 0
        {
            var temp1 i32 = num * 10;
            temp1
        }
        else
        {
            var temp2 i64 = num / 10;
            temp2
        };
    rv
}

fun whileLoop(num i32) i32
{
    var i i32 = 0;
    var rv i32 = 1;
    while i < num
    {
        rv = rv * 2;
        i = i + 1;
    }

    rv
}

fun nestedLoop(num i32) i32
{
    var i i32 = 0;
    var rv i32 = 1;
    while i < num
    {
        rv = if i % 2 == 0 {rv * 2} else {rv * 3};

        var j i32 = 0;
        while j < i
        {
            rv = rv + 1;
            j = j + 1;
        }

        i = i + 1;
    }

    rv
}

fun blockExpression(param i32) i32
{
    var x i32 = {
        types_unit(100);
        types_bool(param > 0, param % 12 == 5);
        types_i32(param, param)
    };

    x
}

extern fun extern1();

fun externTest() u64
{
    # call extern function declared before this function
    extern1();

    # call extern function declared after this function
    extern2(5, true)
}

extern fun extern2(p1 i32, p2 bool) u64;

fun scopes(x i32) i32
{
    var rv i32 = 0;
    if x < 0
    {
        var y i32 = 5;
        rv = y;
    }
    else
    {
        var y i16 = 12;
        rv = y;
    }

    rv
}

fun initTypes()
{
    var empty EmptyType = EmptyType { };

    var test1 Test1 = Test1
    {
        c: "café",
        a: types_i16(1, 2),
        b: true
    };

    var test2 Test2 = Test2
    {
        test: Test1
        {
            a: 1,
            b: false,
            c: "abc",
        },
        n: 12,
    };

    test1.b = false;
    test2.test.a += 7;
}

type EmptyType {}

type Test2
{
    test Test1,
    n i32,
}

type Test1
{
    a i32,
    b bool,
    c str
}
